<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fir1: FIR1</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fir1
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">FIR1 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><img src="fir.png" alt="alt tag" class="inline"/></p>
<p>An efficient finite impulse response (FIR) filter class in C++, JAVA wrapper for Android and Python wrapper.</p>
<p>The floating point class offers also adaptive filtering using the least mean square (LMS) or normalised least mean square (NLMS) algorithm.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Installation</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
Ubuntu packages for xenial, bionic and focal</h2>
<p>Add this repository to your package manager: </p><div class="fragment"><div class="line">sudo add-apt-repository ppa:berndporr/dsp</div>
<div class="line">sudo apt-get update</div>
<div class="line">sudo apt install fir1</div>
<div class="line">sudo apt install fir1-dev</div>
</div><!-- fragment --><p>This adds <code>fir1-dev</code> and <code>fir1</code> to your package list. The demo files are in <code>/usr/share/doc/fir1-dev</code>. Copy them into a working directory, type <code>gunzip *.gz</code>, <code>cmake .</code> and <code>make</code>.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
MacOS packages (homebrew)</h2>
<p>Make sure you have the homebrew package manager installed: <a href="https://brew.sh/">https://brew.sh/</a></p>
<p>Add the homebrew tap:</p>
<div class="fragment"><div class="line">brew tap berndporr/dsp</div>
</div><!-- fragment --><p>and then install the fir filter package with:</p>
<div class="fragment"><div class="line">brew install fir</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md4"></a>
Linux / Unix / MACOSX: compilation from source</h2>
<p>The build system is <code>cmake</code>. Install the library with the standard sequence: </p><div class="fragment"><div class="line">cmake .</div>
<div class="line">make</div>
<div class="line">sudo make install</div>
<div class="line">sudo ldconfig</div>
</div><!-- fragment --><p>or for debugging run cmake with: </p><div class="fragment"><div class="line">By default optimised release libraries are generated.</div>
<div class="line"> </div>
<div class="line">### Windows</div>
<div class="line"> </div>
<div class="line">Under windows only the static library is generated which</div>
<div class="line">should be used for your code development.</div>
</div><!-- fragment --><p>cmake -G "Visual Studio 15 2017 Win64" . ``` and then start Visual C++ and compile it. Usually you want to compile both the release and debug libraries because they are not compatible to each other under Windows.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Android / JAVA</h2>
<p>The subdirectory <code>firj</code> contains an Android project. Load it into Android studio and build it either as a release or debug binary. This generates an Android aar which you import into your project. See the <code>InstrumentedTest.java</code> for an instructional example.</p>
<p>The pre-compiled libraries are here: </p><div class="fragment"><div class="line"> {Firj/firj/build/outputs/aar/firj-*.aar```}</div>
<div class="line"> </div>
<div class="line">### Python</div>
<div class="line"> </div>
<div class="line">#### Installation from the python package index (PyPi)</div>
<div class="line"> </div>
<div class="line">Windows / Linux / Mac</div>
</div><!-- fragment --> <pre class="fragment">pip3 install fir1
</pre> <div class="fragment"><div class="line">under Windows it might be just `pip` for python3.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">#### Installation from source</div>
<div class="line"> </div>
<div class="line">Windows / Linux / Mac: make sure that you have swig and a C++ compiler installed. Then type:</div>
</div><!-- fragment --> <pre class="fragment">python3 setup.py install
</pre> <div class="fragment"><div class="line">## How to use it</div>
<div class="line"> </div>
<div class="line">### cmake</div>
<div class="line"> </div>
<div class="line">Add to your `CMakeLists.txt` either</div>
</div><!-- fragment --><p>target_link_libraries(myexecutable fir) </p><div class="fragment"><div class="line">for the dynamic library or</div>
</div><!-- fragment --><p>target_link_libraries(myexecutable fir_static) </p><div class="fragment"><div class="line">for the statically linked library.</div>
<div class="line"> </div>
<div class="line">You can also use `find_package(fir)`.</div>
<div class="line"> </div>
<div class="line">### Generating the FIR filter coefficients</div>
<div class="line"> </div>
<div class="line">Set the coefficients either with a C floating point array or</div>
<div class="line">with a text file containing the coefficients. The text file or</div>
<div class="line">the floating point array with the</div>
<div class="line">coefficients can easily be generated by Python or OCTAVE/MATLAB:</div>
<div class="line"> </div>
<div class="line">#### Python</div>
<div class="line">Use the `firwin` command to generate the coefficients:</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md6"></a>
Sampling rate</h1>
<p>fs = 1000 </p>
<h1><a class="anchor" id="autotoc_md7"></a>
bandstop between 45 and 55 Hz:</h1>
<p>f1 = 45 f2 = 55 b = signal.firwin(999,[f1/fs*2,f2/fs*2]) </p><div class="fragment"><div class="line">For fixed point you need to scale up the coefficients,</div>
<div class="line">for example by 15 bits: b*32768.</div>
<div class="line"> </div>
<div class="line">#### octave/MATLAB:</div>
</div><!-- fragment --><p>octave:1&gt; h=fir1(100,0.1); </p><div class="fragment"><div class="line">which creates the coefficients of a lowpass filter with 100 taps</div>
<div class="line">and normalised cutoff 0.1 to Nyquist.</div>
<div class="line"> </div>
<div class="line">Again, for fixed point &quot;h&quot; needs to be scaled.</div>
<div class="line"> </div>
<div class="line">### Initialisation</div>
<div class="line"> </div>
<div class="line">#### C++ floating point FIR filter:</div>
</div><!-- fragment --><p><a class="el" href="classFir1.html">Fir1</a> fir("h.dat"); </p><div class="fragment"><div class="line">or import the coefficients as a const double array:</div>
</div><!-- fragment --><p><a class="el" href="classFir1.html">Fir1</a> fir(coefficients) </p><div class="fragment"><div class="line">there is also an option to import a non-const array (for example</div>
<div class="line">generated with the ifft) and using std::vector.</div>
<div class="line"> </div>
<div class="line">#### C++ integer FIR filter:</div>
</div><!-- fragment --><p>Fir1fixed fir("h_fixed.dat",12); </p><div class="fragment"><div class="line">where the coefficients have been scaled up by 2^12 and the</div>
<div class="line">filter will scale them down by this amount (with the help of</div>
<div class="line">a bitshift operation).</div>
<div class="line"> </div>
<div class="line">#### JAVA:</div>
</div><!-- fragment --><p><a class="el" href="classFir1.html">Fir1</a> fir = new <a class="el" href="classFir1.html">Fir1(coeff)</a>; </p><div class="fragment"><div class="line">where `coeff` is an array of double precision coefficients</div>
<div class="line">and returns the fir filter class.</div>
<div class="line"> </div>
<div class="line">#### Python</div>
</div><!-- fragment --><p>f = fir1.Fir1(coeff) </p><div class="fragment"><div class="line">### Realtime filtering</div>
<div class="line"> </div>
<div class="line">#### C++ double:</div>
</div><!-- fragment --><p>double b = fir.filter(a); </p><div class="fragment"><div class="line">#### C++ integer:</div>
</div><!-- fragment --><p>int b = fir.filter(a); </p><div class="fragment"><div class="line">#### JAVA:</div>
</div><!-- fragment --><p>double b = fir.filter(a) </p><div class="fragment"><div class="line">#### Python</div>
</div><!-- fragment --><p>b = f.filter(a) </p><div class="fragment"><div class="line">### Utility methods</div>
<div class="line"> </div>
<div class="line">These functions are the same in C++, JAVA and Python:</div>
<div class="line"> </div>
<div class="line">+ `getTaps()` returns the length of the FIR filter kernel.</div>
<div class="line">+ `reset()` sets all delay lines to zero.</div>
<div class="line">+ `zeroCoeff()` sets all coefficients to zero.</div>
<div class="line"> </div>
<div class="line">Retreiving the coefficients/kernel from the FIR filter is different depending on the</div>
<div class="line">language used:</div>
<div class="line"> </div>
<div class="line">#### C++</div>
<div class="line">+ `void getCoeff(double* target, unsigned length) const` copies the FIR kernel into the</div>
<div class="line">given C array of `double`s with length `length`.</div>
<div class="line"> </div>
<div class="line">   If `length` exceeds the length of the filter kernel, the result is zero-padded to fill</div>
<div class="line">the given array.</div>
<div class="line"> </div>
<div class="line">   If `length` is smaller than the filter kernel, a `std::out_of_range` exception is thrown.</div>
<div class="line">   </div>
<div class="line">+ `std::vector&lt;double&gt; getCoeffVector() const` returns a copy of the filter kernel.</div>
<div class="line"> </div>
<div class="line">#### Python</div>
<div class="line">+ `getCoeff(n : int) -&gt; numpy.array` as per the C++ method, following the zero-padding</div>
<div class="line">and exception-throwing behaviour of the C++. The returned array will have `n` elements.</div>
<div class="line">+ `getCoeff() -&gt; numpy.array` additional to the C++ methods, this returns an numpy array</div>
<div class="line">which is a copy of the filter kernel. This is probably the default use case in Python.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">#### JAVA</div>
<div class="line">+ `double[] getCoeff()` returns a double array of the filter kernel.</div>
<div class="line">+ `double[] getCoeff(n : int)` as per the C++ method, following the zero-padding</div>
<div class="line">and exception-throwing behaviour of the C++. The returned array will have `n` elements.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">### Destructor</div>
<div class="line"> </div>
<div class="line">#### C++</div>
</div><!-- fragment --><p>delete fir; </p><div class="fragment"><div class="line">#### JAVA</div>
</div><!-- fragment --><p>fir.release(); </p><div class="fragment"><div class="line">to release the underlying C++ class.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">## LMS algorithm</div>
<div class="line"> </div>
<div class="line">The least mean square algorithm adjusts the FIR coefficients w_k</div>
<div class="line">with the help of an error signal</div>
</div><!-- fragment --><p>w_k(t+1) = w_k(t) + learning_rate * buffer_k(t) * error(t) ``<code> using the function</code>lms_update(error)<code>while performing the filtering with</code>filter()`.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
How to use the filter</h3>
<ul>
<li>Construct the Fir filter with all coefficients set to zero: <code><a class="el" href="classFir1.html">Fir1(nCoeff)</a></code></li>
<li>Set the learning_rate with the method <code>setLearningRate(learning_rate)</code>.</li>
<li>Define the signal1 to the FIR filter and use its standard <code>filter</code> method to filter it.</li>
<li>Define your error which needs to be minimised: <code>error = signal2 - fir_filter_output</code></li>
<li>Feed the error back into the filter with the method <code>lms_update(error)</code>.</li>
</ul>
<p>The <code>lmsdemo</code> in the demo directory makes this concept much clearer how to remove artefacts with this method.</p>
<p><img src="lms.png" alt="alt tag" class="inline"/></p>
<p>The above plot shows the filter in action which removes 50Hz noise with the adaptive filter. Learning is very fast and the learning rate here is deliberately kept low to show how it works.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Stability</h3>
<p>The FIR filter itself is stable but the error signal changes the filter coefficients which in turn change the error and so on. There is a rule of thumb that the learning rate should be less than the "tap power" of the input signal which is just the sum of all squared values held in the different taps: </p><div class="fragment"><div class="line">learning_rate &lt; 1/getTapInputPower()</div>
</div><!-- fragment --><p>That allows an adaptive learning rate which is called "normalised LMS". From my experiments that works in theory but in practise the realtime value of getTapInputPower() can make the algorithm easily unstable because it might suggest infinite learning rates and can fluctuate wildly. A better approach is to keep the learning rate constant and rather control the power of the input signal by, for example, normalising the input signal or limiting it.</p>
<p>See the demo below which removes 50Hz from an ECG which uses a normalised 50Hz signal which guarantees stability by design.</p>
<h3><a class="anchor" id="autotoc_md10"></a>
JAVA/Python</h3>
<p>The commands under JAVA and Python are identical to C++.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Demos</h2>
<p>Demo programs are in the "demo" directory which show how to use the filters for both floating point and fixed point.</p><ol type="1">
<li><code>firdemo</code> sends an impulse into the filter and you should see the impulse response at its output.</li>
<li><code>fixeddemo</code> filters an example ECG with 50Hz noise. The coefficients are 12 bit and you can generate them either with OCTAVE/MATLAB or Python. The scripts are also provided.</li>
<li><code>lmsdemo</code> filters out 50Hz noise from an ECG with the help of adaptive filtering by using the 50Hz powerline frequency as the input to the filter. This can be replaced by any reference artefact signal or signal which is correlated with the artefact.</li>
<li>JAVA has an <code>InstrumentedTest</code> which filters both a delta pulse and a step function.</li>
<li>filter_ecg.py performs the filtering of an ECG in python using the fir1 python module which in turn calls internally the C++ functions.</li>
</ol>
<h2><a class="anchor" id="autotoc_md12"></a>
C++ documentation</h2>
<p>The doxygen generated documentation can be found here:</p>
<ul>
<li>Online: <a href="http://berndporr.github.io/fir1/index.html">http://berndporr.github.io/fir1/index.html</a></li>
<li>PDF: <a href="https://github.com/berndporr/fir1/tree/master/docs/pdf">https://github.com/berndporr/fir1/tree/master/docs/pdf</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md13"></a>
Unit tests</h2>
<p>Under C++ just run <code>make test</code> or <code>ctest</code>.</p>
<p>The JAVA wrapper contains an instrumented test which you can run on your Android device.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Credits</h2>
<p>This library has been adapted form Graeme Hattan's original C code.</p>
<p>Enjoy!</p>
<p>Bernd Porr &amp; Nick Bailey </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 23 2021 22:45:58 for fir1 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
