

An efficient finite impulse response (F\+IR) filter class in C++, J\+A\+VA wrapper for Android and Python wrapper.

The floating point class offers also adaptive filtering using the least mean square (L\+MS) or normalised least mean square (N\+L\+MS) algorithm.\hypertarget{md_README_autotoc_md1}{}\doxysubsection{Installation}\label{md_README_autotoc_md1}
\hypertarget{md_README_autotoc_md2}{}\doxysubsubsection{Ubuntu packages for xenial, bionic and focal}\label{md_README_autotoc_md2}
Add this repository to your package manager\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{sudo add-\/apt-\/repository ppa:berndporr/dsp}
\DoxyCodeLine{sudo apt-\/get update}
\DoxyCodeLine{sudo apt install fir1}
\DoxyCodeLine{sudo apt install fir1-\/dev}
\end{DoxyCode}


This adds {\ttfamily fir1-\/dev} and {\ttfamily fir1} to your package list. The demo files are in {\ttfamily /usr/share/doc/fir1-\/dev}. Copy them into a working directory, type {\ttfamily gunzip $\ast$.gz}, {\ttfamily cmake .} and {\ttfamily make}.\hypertarget{md_README_autotoc_md3}{}\doxysubsubsection{Mac\+O\+S packages (homebrew)}\label{md_README_autotoc_md3}
Make sure you have the homebrew package manager installed\+: \href{https://brew.sh/}{\texttt{ https\+://brew.\+sh/}}

Add the homebrew tap\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{brew tap berndporr/dsp}
\end{DoxyCode}


and then install the fir filter package with\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{brew install fir}
\end{DoxyCode}
\hypertarget{md_README_autotoc_md4}{}\doxysubsubsection{Linux / Unix / M\+A\+C\+O\+S\+X\+: compilation from source}\label{md_README_autotoc_md4}
The build system is {\ttfamily cmake}. Install the library with the standard sequence\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{cmake .}
\DoxyCodeLine{make}
\DoxyCodeLine{sudo make install}
\DoxyCodeLine{sudo ldconfig}
\end{DoxyCode}


or for debugging run cmake with\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{By default optimised release libraries are generated.}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\# Windows}
\DoxyCodeLine{}
\DoxyCodeLine{Under windows only the static library is generated which}
\DoxyCodeLine{should be used for your code development.}
\end{DoxyCode}


cmake -\/G \char`\"{}\+Visual Studio 15 2017 Win64\char`\"{} . \`{}\`{}\`{} and then start Visual C++ and compile it. Usually you want to compile both the release and debug libraries because they are not compatible to each other under Windows.\hypertarget{md_README_autotoc_md5}{}\doxysubsubsection{Android / J\+A\+VA}\label{md_README_autotoc_md5}
The subdirectory {\ttfamily firj} contains an Android project. Load it into Android studio and build it either as a release or debug binary. This generates an Android aar which you import into your project. See the {\ttfamily Instrumented\+Test.\+java} for an instructional example.

The pre-\/compiled libraries are here\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{Firj/firj/build/outputs/aar/firj-\/*.aar```\}}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\# Python}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\#\# Installation from the python package index (PyPi)}
\DoxyCodeLine{}
\DoxyCodeLine{Windows / Linux / Mac}
\end{DoxyCode}
 \begin{DoxyVerb}pip3 install fir1
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{under Windows it might be just `pip` for python3.}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\#\# Installation from source}
\DoxyCodeLine{}
\DoxyCodeLine{Windows / Linux / Mac: make sure that you have swig and a C++ compiler installed. Then type:}
\end{DoxyCode}
 \begin{DoxyVerb}python3 setup.py install
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{\#\# How to use it}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\# cmake}
\DoxyCodeLine{}
\DoxyCodeLine{Add to your `CMakeLists.txt` either}
\end{DoxyCode}


target\+\_\+link\+\_\+libraries(myexecutable fir) 
\begin{DoxyCode}{0}
\DoxyCodeLine{for the dynamic library or}
\end{DoxyCode}


target\+\_\+link\+\_\+libraries(myexecutable fir\+\_\+static) 
\begin{DoxyCode}{0}
\DoxyCodeLine{for the statically linked library.}
\DoxyCodeLine{}
\DoxyCodeLine{You can also use `find\_package(fir)`.}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\# Generating the FIR filter coefficients}
\DoxyCodeLine{}
\DoxyCodeLine{Set the coefficients either with a C floating point array or}
\DoxyCodeLine{with a text file containing the coefficients. The text file or}
\DoxyCodeLine{the floating point array with the}
\DoxyCodeLine{coefficients can easily be generated by Python or OCTAVE/MATLAB:}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\#\# Python}
\DoxyCodeLine{Use the `firwin` command to generate the coefficients:}
\end{DoxyCode}
\hypertarget{md_README_autotoc_md6}{}\doxysubsection{Sampling rate}\label{md_README_autotoc_md6}
fs = 1000 \hypertarget{md_README_autotoc_md7}{}\doxysubsection{bandstop between 45 and 55 Hz\+:}\label{md_README_autotoc_md7}
f1 = 45 f2 = 55 b = signal.\+firwin(999,\mbox{[}f1/fs$\ast$2,f2/fs$\ast$2\mbox{]}) 
\begin{DoxyCode}{0}
\DoxyCodeLine{For fixed point you need to scale up the coefficients,}
\DoxyCodeLine{for example by 15 bits: b*32768.}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\#\# octave/MATLAB:}
\end{DoxyCode}


octave\+:1$>$ h=fir1(100,0.\+1); 
\begin{DoxyCode}{0}
\DoxyCodeLine{which creates the coefficients of a lowpass filter with 100 taps}
\DoxyCodeLine{and normalised cutoff 0.1 to Nyquist.}
\DoxyCodeLine{}
\DoxyCodeLine{Again, for fixed point "h" needs to be scaled.}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\# Initialisation}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\#\# C++ floating point FIR filter:}
\end{DoxyCode}


\mbox{\hyperlink{classFir1}{Fir1}} fir(\char`\"{}h.\+dat\char`\"{}); 
\begin{DoxyCode}{0}
\DoxyCodeLine{or import the coefficients as a const double array:}
\end{DoxyCode}


\mbox{\hyperlink{classFir1}{Fir1}} fir(coefficients) 
\begin{DoxyCode}{0}
\DoxyCodeLine{there is also an option to import a non-\/const array (for example}
\DoxyCodeLine{generated with the ifft) and using std::vector.}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\#\# C++ integer FIR filter:}
\end{DoxyCode}


Fir1fixed fir(\char`\"{}h\+\_\+fixed.\+dat\char`\"{},12); 
\begin{DoxyCode}{0}
\DoxyCodeLine{where the coefficients have been scaled up by 2\string^12 and the}
\DoxyCodeLine{filter will scale them down by this amount (with the help of}
\DoxyCodeLine{a bitshift operation).}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\#\# JAVA:}
\end{DoxyCode}


\mbox{\hyperlink{classFir1}{Fir1}} fir = new \mbox{\hyperlink{classFir1}{Fir1(coeff)}}; 
\begin{DoxyCode}{0}
\DoxyCodeLine{where `coeff` is an array of double precision coefficients}
\DoxyCodeLine{and returns the fir filter class.}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\#\# Python}
\end{DoxyCode}


f = fir1.\+Fir1(coeff) 
\begin{DoxyCode}{0}
\DoxyCodeLine{\#\#\# Realtime filtering}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\#\# C++ double:}
\end{DoxyCode}


double b = fir.\+filter(a); 
\begin{DoxyCode}{0}
\DoxyCodeLine{\#\#\#\# C++ integer:}
\end{DoxyCode}


int b = fir.\+filter(a); 
\begin{DoxyCode}{0}
\DoxyCodeLine{\#\#\#\# JAVA:}
\end{DoxyCode}


double b = fir.\+filter(a) 
\begin{DoxyCode}{0}
\DoxyCodeLine{\#\#\#\# Python}
\end{DoxyCode}


b = f.\+filter(a) 
\begin{DoxyCode}{0}
\DoxyCodeLine{\#\#\# Utility methods}
\DoxyCodeLine{}
\DoxyCodeLine{These functions are the same in C++, JAVA and Python:}
\DoxyCodeLine{}
\DoxyCodeLine{+ `getTaps()` returns the length of the FIR filter kernel.}
\DoxyCodeLine{+ `reset()` sets all delay lines to zero.}
\DoxyCodeLine{+ `zeroCoeff()` sets all coefficients to zero.}
\DoxyCodeLine{}
\DoxyCodeLine{Retreiving the coefficients/kernel from the FIR filter is different depending on the}
\DoxyCodeLine{language used:}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\#\# C++}
\DoxyCodeLine{+ `void getCoeff(double* target, unsigned length) const` copies the FIR kernel into the}
\DoxyCodeLine{given C array of `double`s with length `length`.}
\DoxyCodeLine{}
\DoxyCodeLine{   If `length` exceeds the length of the filter kernel, the result is zero-\/padded to fill}
\DoxyCodeLine{the given array.}
\DoxyCodeLine{}
\DoxyCodeLine{   If `length` is smaller than the filter kernel, a `std::out\_of\_range` exception is thrown.}
\DoxyCodeLine{   }
\DoxyCodeLine{+ `std::vector<double> getCoeffVector() const` returns a copy of the filter kernel.}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\#\# Python}
\DoxyCodeLine{+ `getCoeff(n : int) -\/> numpy.array` as per the C++ method, following the zero-\/padding}
\DoxyCodeLine{and exception-\/throwing behaviour of the C++. The returned array will have `n` elements.}
\DoxyCodeLine{+ `getCoeff() -\/> numpy.array` additional to the C++ methods, this returns an numpy array}
\DoxyCodeLine{which is a copy of the filter kernel. This is probably the default use case in Python.}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\#\# JAVA}
\DoxyCodeLine{+ `double[] getCoeff()` returns a double array of the filter kernel.}
\DoxyCodeLine{+ `double[] getCoeff(n : int)` as per the C++ method, following the zero-\/padding}
\DoxyCodeLine{and exception-\/throwing behaviour of the C++. The returned array will have `n` elements.}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\# Destructor}
\DoxyCodeLine{}
\DoxyCodeLine{\#\#\#\# C++}
\end{DoxyCode}


delete fir; 
\begin{DoxyCode}{0}
\DoxyCodeLine{\#\#\#\# JAVA}
\end{DoxyCode}


fir.\+release(); 
\begin{DoxyCode}{0}
\DoxyCodeLine{to release the underlying C++ class.}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\#\# LMS algorithm}
\DoxyCodeLine{}
\DoxyCodeLine{The least mean square algorithm adjusts the FIR coefficients w\_k}
\DoxyCodeLine{with the help of an error signal}
\end{DoxyCode}


w\+\_\+k(t+1) = w\+\_\+k(t) + learning\+\_\+rate $\ast$ buffer\+\_\+k(t) $\ast$ error(t) \`{}\`{}{\ttfamily  using the function}lms\+\_\+update(error){\ttfamily while performing the filtering with}filter()\`{}.\hypertarget{md_README_autotoc_md8}{}\doxyparagraph{How to use the filter}\label{md_README_autotoc_md8}

\begin{DoxyItemize}
\item Construct the Fir filter with all coefficients set to zero\+: {\ttfamily \mbox{\hyperlink{classFir1}{Fir1(n\+Coeff)}}}
\item Set the learning\+\_\+rate with the method {\ttfamily set\+Learning\+Rate(learning\+\_\+rate)}.
\item Define the signal1 to the F\+IR filter and use its standard {\ttfamily filter} method to filter it.
\item Define your error which needs to be minimised\+: {\ttfamily error = signal2 -\/ fir\+\_\+filter\+\_\+output}
\item Feed the error back into the filter with the method {\ttfamily lms\+\_\+update(error)}.
\end{DoxyItemize}

The {\ttfamily lmsdemo} in the demo directory makes this concept much clearer how to remove artefacts with this method.



The above plot shows the filter in action which removes 50Hz noise with the adaptive filter. Learning is very fast and the learning rate here is deliberately kept low to show how it works.\hypertarget{md_README_autotoc_md9}{}\doxyparagraph{Stability}\label{md_README_autotoc_md9}
The F\+IR filter itself is stable but the error signal changes the filter coefficients which in turn change the error and so on. There is a rule of thumb that the learning rate should be less than the \char`\"{}tap power\char`\"{} of the input signal which is just the sum of all squared values held in the different taps\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{learning\_rate < 1/getTapInputPower()}
\end{DoxyCode}


That allows an adaptive learning rate which is called \char`\"{}normalised L\+M\+S\char`\"{}. From my experiments that works in theory but in practise the realtime value of get\+Tap\+Input\+Power() can make the algorithm easily unstable because it might suggest infinite learning rates and can fluctuate wildly. A better approach is to keep the learning rate constant and rather control the power of the input signal by, for example, normalising the input signal or limiting it.

See the demo below which removes 50Hz from an E\+CG which uses a normalised 50Hz signal which guarantees stability by design.\hypertarget{md_README_autotoc_md10}{}\doxyparagraph{J\+A\+V\+A/\+Python}\label{md_README_autotoc_md10}
The commands under J\+A\+VA and Python are identical to C++.\hypertarget{md_README_autotoc_md11}{}\doxysubsubsection{Demos}\label{md_README_autotoc_md11}
Demo programs are in the \char`\"{}demo\char`\"{} directory which show how to use the filters for both floating point and fixed point.
\begin{DoxyEnumerate}
\item {\ttfamily firdemo} sends an impulse into the filter and you should see the impulse response at its output.
\item {\ttfamily fixeddemo} filters an example E\+CG with 50Hz noise. The coefficients are 12 bit and you can generate them either with O\+C\+T\+A\+V\+E/\+M\+A\+T\+L\+AB or Python. The scripts are also provided.
\item {\ttfamily lmsdemo} filters out 50Hz noise from an E\+CG with the help of adaptive filtering by using the 50Hz powerline frequency as the input to the filter. This can be replaced by any reference artefact signal or signal which is correlated with the artefact.
\item J\+A\+VA has an {\ttfamily Instrumented\+Test} which filters both a delta pulse and a step function.
\item filter\+\_\+ecg.\+py performs the filtering of an E\+CG in python using the fir1 python module which in turn calls internally the C++ functions.
\end{DoxyEnumerate}\hypertarget{md_README_autotoc_md12}{}\doxysubsubsection{C++ documentation}\label{md_README_autotoc_md12}
The doxygen generated documentation can be found here\+:


\begin{DoxyItemize}
\item Online\+: \href{http://berndporr.github.io/fir1/index.html}{\texttt{ http\+://berndporr.\+github.\+io/fir1/index.\+html}}
\item P\+DF\+: \href{https://github.com/berndporr/fir1/tree/master/docs/pdf}{\texttt{ https\+://github.\+com/berndporr/fir1/tree/master/docs/pdf}}
\end{DoxyItemize}\hypertarget{md_README_autotoc_md13}{}\doxysubsubsection{Unit tests}\label{md_README_autotoc_md13}
Under C++ just run {\ttfamily make test} or {\ttfamily ctest}.

The J\+A\+VA wrapper contains an instrumented test which you can run on your Android device.\hypertarget{md_README_autotoc_md14}{}\doxysubsubsection{Credits}\label{md_README_autotoc_md14}
This library has been adapted form Graeme Hattan\textquotesingle{}s original C code.

Enjoy!

Bernd Porr \& Nick Bailey 